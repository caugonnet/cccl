//===----------------------------------------------------------------------===//
//
// Part of CUDASTF in CUDA C++ Core Libraries,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
// SPDX-FileCopyrightText: Copyright (c) 2022-2024 NVIDIA CORPORATION & AFFILIATES.
//
//===----------------------------------------------------------------------===//

/**
 * @file
 *
 * @brief Example: Thrust device_vector with an allocator backed by a data_place.
 *        Uses thrust::mr::memory_resource to wrap data_place, then
 *        thrust::mr::allocator to create a compatible allocator.
 *        Storage is allocated via data_place::allocate (device, composite/VMM,
 *        or other place types).
 */

#include <thrust/copy.h>
#include <thrust/device_ptr.h>
#include <thrust/device_vector.h>
#include <thrust/execution_policy.h>
#include <thrust/host_vector.h>
#include <thrust/iterator/counting_iterator.h>
#include <thrust/mr/allocator.h>
#include <thrust/mr/memory_resource.h>
#include <thrust/transform.h>

#include <cuda/experimental/__stf/places/blocked_partition.cuh>
#include <cuda/experimental/__stf/places/exec/green_context.cuh>
#include <cuda/experimental/stf.cuh>

#include <iostream>

using namespace cuda::experimental::stf;

// Thrust memory resource that delegates to a data_place.
class data_place_memory_resource final : public thrust::mr::memory_resource<thrust::device_ptr<void>>
{
public:
  explicit data_place_memory_resource(const data_place& place)
      : place_(place)
  {}

  pointer do_allocate(std::size_t bytes, std::size_t /*alignment*/) override
  {
    void* raw = place_.allocate(static_cast<std::ptrdiff_t>(bytes));
    return thrust::device_ptr<void>(raw);
  }

  void do_deallocate(pointer p, std::size_t bytes, std::size_t /*alignment*/) override
  {
    place_.deallocate(p.get(), bytes);
  }

  bool do_is_equal(const memory_resource& other) const noexcept override
  {
    auto* o = dynamic_cast<const data_place_memory_resource*>(&other);
    return o && place_ == o->place_;
  }

private:
  data_place place_;
};

template <typename T>
using data_place_allocator = thrust::mr::allocator<T, data_place_memory_resource>;

// Run the Thrust example with the given data_place; returns true if the check passed.
bool run_with_place(const data_place& place, const char* label)
{
  const size_t n = 1024 * 1024;

  data_place_memory_resource memres(place);
  data_place_allocator<double> alloc(&memres);
  thrust::device_vector<double, data_place_allocator<double>> d_vec(n, 0.0, alloc);

  thrust::transform(
    thrust::device,
    thrust::counting_iterator<size_t>(0),
    thrust::counting_iterator<size_t>(n),
    d_vec.begin(),
    [] _CCCL_DEVICE(size_t i) {
      return 2.0 * static_cast<double>(i);
    });

  thrust::host_vector<double> h_sample(4);
  thrust::copy(d_vec.begin(), d_vec.begin() + 4, h_sample.begin());

  bool ok = (h_sample[0] == 0.0 && h_sample[1] == 2.0 && h_sample[2] == 4.0 && h_sample[3] == 6.0);
  if (!ok)
  {
    std::cerr << "thrust_device_data_place_allocator: " << label << " (" << place.to_string() << "): FAILED\n";
  }
  return ok;
}

int main()
{
  bool all_ok = true;

  // Device 0
  all_ok &= run_with_place(data_place::device(0), "device(0)");

  // All devices (composite, VMM path when multiple devices)
  all_ok &= run_with_place(data_place::composite(blocked_partition(), exec_place::all_devices()),
                           "composite(blocked_partition, all_devices)");

#if _CCCL_CTK_AT_LEAST(12, 4)
  // Green context grid (composite, VMM path)
  {
    async_resources_handle handle;
    const int num_sms = 8;
    const int dev_id  = 0;
    auto gc_helper    = handle.get_gc_helper(dev_id, num_sms);
    if (gc_helper->get_count() >= 1)
    {
      auto where     = gc_helper->get_grid(true);
      data_place cdp = data_place::composite(blocked_partition(), where);
      all_ok &= run_with_place(cdp, "composite(blocked_partition, green_context_grid)");
    }
  }
#endif

  return all_ok ? 0 : 1;
}
